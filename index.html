<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stack Tecnológica para Sistema Gerencial</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-btn.active {
            border-color: #3b82f6;
            color: #3b82f6;
            font-weight: 600;
        }

        /* Simple animation for content fade in */
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
</head>

<body class="bg-slate-50 text-slate-800">

    <div class="container mx-auto p-4 sm:p-6 lg:p-8">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-slate-900">Guia Interativo da Stack Tecnológica</h1>
            <p class="mt-2 text-lg text-slate-600">Recomendações para um Sistema Gerencial com Vue.js e Node.js</p>
        </header>

        <nav class="mb-8 border-b border-slate-200">
            <ul class="flex flex-wrap -mb-px text-sm font-medium text-center text-slate-500">
                <li class="mr-2">
                    <button class="tab-btn inline-block p-4 border-b-2 border-transparent rounded-t-lg hover:text-slate-600 hover:border-slate-300" data-tab="arquitetura">
                        🏛️ Arquitetura
                    </button>
                </li>
                <li class="mr-2">
                    <button class="tab-btn inline-block p-4 border-b-2 border-transparent rounded-t-lg hover:text-slate-600 hover:border-slate-300" data-tab="frontend">
                        🎨 Frontend
                    </button>
                </li>
                <li class="mr-2">
                    <button class="tab-btn inline-block p-4 border-b-2 border-transparent rounded-t-lg hover:text-slate-600 hover:border-slate-300" data-tab="backend">
                        ⚙️ Backend
                    </button>
                </li>
                <li class="mr-2">
                    <button class="tab-btn inline-block p-4 border-b-2 border-transparent rounded-t-lg hover:text-slate-600 hover:border-slate-300" data-tab="autenticacao">
                        🔑 Autenticação
                    </button>
                </li>
                <li>
                    <button class="tab-btn inline-block p-4 border-b-2 border-transparent rounded-t-lg hover:text-slate-600 hover:border-slate-300" data-tab="devops">
                        🚀 DevOps
                    </button>
                </li>
            </ul>
        </nav>

        <main>
            <section id="arquitetura" class="tab-content fade-in">
                <h2 class="text-3xl font-bold mb-6 text-slate-900">Escolha da Arquitetura</h2>
                <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-2xl font-semibold mb-3 text-blue-600">Monolito Modular</h3>
                        <p class="mb-4 text-slate-600">Uma única aplicação, implantada como uma unidade, mas com o código-fonte organizado em módulos de negócio bem definidos. Ideal para iniciar projetos, pois simplifica o desenvolvimento e o deploy.</p>
                        <div class="relative">
                            <button onclick="copyCode('monolith-code', this)" class="absolute top-2 right-2 bg-slate-200 text-slate-700 px-2 py-1 rounded text-xs hover:bg-slate-300">Copiar</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-md text-sm overflow-x-auto"><code id="monolith-code">meu-sistema-monolito/
├── src/
│   ├── modules/
│   │   ├── auth/
│   │   ├── users/
│   │   ├── inventory/
│   │   └── billing/
│   ├── shared/
│   ├── app.module.ts
│   └── main.ts
├── package.json
└── Dockerfile
</code></pre>
                        </div>
                    </div>

                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-2xl font-semibold mb-3 text-green-600">Microserviços</h3>
                        <p class="mb-4 text-slate-600">O sistema é uma coleção de serviços autônomos e independentes, cada um focado em uma área de negócio. Permite deploy e escalabilidade independentes, mas aumenta a complexidade operacional.</p>
                        <div class="relative">
                            <button onclick="copyCode('microservices-code', this)" class="absolute top-2 right-2 bg-slate-200 text-slate-700 px-2 py-1 rounded text-xs hover:bg-slate-300">Copiar</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-md text-sm overflow-x-auto"><code id="microservices-code">meu-sistema-microservicos/
├── services/
│   ├── auth-service/
│   ├── user-service/
│   ├── inventory-service/
│   └── billing-service/
├── api-gateway/
└── docker-compose.yml
</code></pre>
                        </div>
                    </div>
                </div>

                <div class="mt-10 bg-blue-100 border-l-4 border-blue-500 text-blue-800 p-6 rounded-r-lg shadow">
                    <h3 class="text-2xl font-bold mb-2">⭐ Recomendação: Comece com um Monólito Modular</h3>
                    <p>Para um novo projeto, a abordagem mais pragmática é iniciar com um monólito bem estruturado. Isso acelera o desenvolvimento inicial e reduz a complexidade. A chave é manter a disciplina modular, o que facilitará a extração de um módulo para um microserviço no futuro, se e quando for necessário. Essa abordagem evolutiva (Monolith-First) mitiga os riscos de uma complexidade prematura.</p>
                </div>
            </section>

            <section id="frontend" class="tab-content fade-in">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Vue 3</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-green-600 bg-green-200 mb-3">
                            Core Framework
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> A versão mais recente do popular framework progressivo JavaScript.
                            <br><strong>Como funciona:</strong> Utiliza a Composition API para organizar a lógica em funções reutilizáveis (composables), melhorando a manutenibilidade de componentes complexos.
                            <br><strong>Vantagens:</strong> Alta performance, excelente documentação e uma curva de aprendizado suave. Ideal para construir interfaces de usuário reativas e modernas.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">TypeScript</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200 mb-3">
                            Linguagem / Superset
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Um superset do JavaScript que adiciona tipagem estática opcional.
                            <br><strong>Como funciona:</strong> O código é escrito em TypeScript e transpilado para JavaScript. Com Vue 3, ele se integra nativamente, permitindo definir tipos para props, estado (Pinia), etc.
                            <br><strong>Vantagens:</strong> Previne bugs, melhora o autocompletar do editor e torna o código mais manutenível. **Altamente recomendado para projetos grandes.**
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Vite</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-purple-600 bg-purple-200 mb-3">
                            Build Tool
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Uma ferramenta de build moderna que serve o código via módulos ES nativos durante o desenvolvimento.
                            <br><strong>Como funciona:</strong> Proporciona um servidor de desenvolvimento extremamente rápido com Hot Module Replacement (HMR) quase instantâneo.
                            <br><strong>Vantagens:</strong> Velocidade de desenvolvimento incomparável, configuração simplificada e otimizações de build para produção.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Pinia</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-yellow-600 bg-yellow-200 mb-3">
                            Gerenciamento de Estado
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> A biblioteca de gerenciamento de estado oficial e recomendada para Vue 3.
                            <br><strong>Como funciona:</strong> Oferece um "store" centralizado para guardar dados que precisam ser compartilhados entre componentes.
                            <br><strong>Vantagens:</strong> Leve, modular, com excelente suporte a TypeScript e uma experiência de desenvolvimento superior ao Vuex.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Quasar Framework</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-indigo-600 bg-indigo-200 mb-3">
                            Framework de UI Multiplataforma
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Um framework completo sobre o Vue.js, focado em "escrever o código uma vez e implantar em todos os lugares".
                            <br><strong>Como funciona:</strong> Oferece um rico conjunto de componentes de UI que se adaptam automaticamente para web, mobile e desktop.
                            <br><strong>Vantagens:</strong> A escolha ideal para projetos web e mobile. Economiza tempo e garante consistência visual e funcional entre as plataformas.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Vue Router</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-red-600 bg-red-200 mb-3">
                            Roteamento
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> A biblioteca oficial para gerenciar as rotas da sua Single Page Application (SPA).
                            <br><strong>Como funciona:</strong> Mapeia URLs do navegador para os componentes Vue correspondentes, permitindo a navegação sem recarregar o site.
                            <br><strong>Vantagens:</strong> Integração perfeita com o ecossistema Vue, suporte a rotas aninhadas e lazy loading.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Axios</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-teal-600 bg-teal-200 mb-3">
                            Cliente HTTP
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Um cliente HTTP baseado em Promises para navegador e node.js.
                            <br><strong>Como funciona:</strong> Simplifica a realização de requisições a APIs (GET, POST, etc.), tratando a transformação de dados e erros de forma elegante.
                            <br><strong>Vantagens:</strong> API fácil de usar, interceptadores para requisições/respostas, cancelamento de requisições e ampla compatibilidade.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Zod</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-orange-600 bg-orange-200 mb-3">
                            Validação de Dados
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Uma biblioteca de declaração e validação de esquemas com foco em TypeScript.
                            <br><strong>Como funciona:</strong> Você define um esquema para a estrutura de dados esperada (ex: respostas de API, inputs de formulário) e o Zod valida se os dados correspondem.
                            <br><strong>Vantagens:</strong> Garante a integridade dos dados que entram no frontend, melhora a segurança e se integra perfeitamente com TypeScript.
                        </p>
                    </div>
                </div>
            </section>

            <section id="backend" class="tab-content fade-in">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">NestJS</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-red-600 bg-red-200 mb-3">
                            Framework Web
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Um framework Node.js para construir aplicações de backend eficientes e escaláveis.
                            <br><strong>Como funciona:</strong> Utiliza TypeScript por padrão e uma arquitetura modular (Controllers, Services), promovendo uma organização de código robusta.
                            <br><strong>Vantagens:</strong> Estrutura opinativa que guia para boas práticas, injeção de dependência nativa e excelente para aplicações corporativas.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">PostgreSQL</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-blue-600 bg-blue-200 mb-3">
                            Banco de Dados
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Um sistema de gerenciamento de banco de dados relacional de código aberto, conhecido por sua robustez.
                            <br><strong>Como funciona:</strong> Armazena dados em tabelas estruturadas com relacionamentos, garantindo a integridade e consistência dos dados.
                            <br><strong>Vantagens:</strong> Confiabilidade, extensibilidade e um conjunto rico de funcionalidades avançadas, perfeito para sistemas gerenciais.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Prisma</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-slate-600 bg-slate-200 mb-3">
                            ORM / Query Builder
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Um ORM (Object-Relational Mapper) de nova geração para Node.js e TypeScript.
                            <br><strong>Como funciona:</strong> Mapeia os modelos do seu banco de dados para objetos TypeScript, permitindo interagir com o banco de forma segura e intuitiva.
                            <br><strong>Vantagens:</strong> Segurança de tipos de ponta a ponta (previne erros), autocompletar e uma API de consulta fluida.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Passport.js + JWT</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-cyan-600 bg-cyan-200 mb-3">
                            Autenticação
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Passport.js é um middleware de autenticação. JWT (JSON Web Token) é um padrão para criar tokens de acesso.
                            <br><strong>Como funciona:</strong> O usuário faz login, o backend gera um JWT e o envia ao frontend. Cada requisição subsequente inclui esse token para provar a identidade.
                            <br><strong>Vantagens:</strong> Abordagem stateless (sem sessão no servidor), modular e um padrão de mercado para proteger APIs.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Zod</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-orange-600 bg-orange-200 mb-3">
                            Validação de Dados
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Uma biblioteca de declaração e validação de esquemas com foco em TypeScript.
                            <br><strong>Como funciona:</strong> Você define um "esquema" para a estrutura de dados esperada. O Zod então valida se os dados recebidos correspondem a esse esquema.
                            <br><strong>Vantagens:</strong> Garante a integridade dos dados na entrada da sua API, previne erros e melhora a segurança.
                        </p>
                    </div>
                </div>
            </section>

            <section id="autenticacao" class="tab-content fade-in">
                <h2 class="text-3xl font-bold mb-2 text-slate-900">Lógica de Autenticação com JWT</h2>
                <p class="mb-8 text-slate-600">Implementando um fluxo seguro com Access Tokens e Refresh Tokens.</p>

                <div class="space-y-8">

                    <!-- Passo 1: Registro -->
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-2xl font-semibold mb-3 text-slate-800">1. Registro de Usuário (Sign-Up)</h3>
                        <p class="mb-4 text-slate-600">O processo inicia quando um novo usuário se cadastra. A senha nunca deve ser salva em texto puro.</p>
                        <ul class="list-disc list-inside space-y-2 mb-4 text-slate-600">
                            <li>O frontend envia `nome`, `email` e `password` para a API.</li>
                            <li>O backend valida os dados (ex: com Zod) para garantir que estão no formato correto.</li>
                            <li>A senha é "hasheada" usando uma biblioteca como o <strong>bcrypt</strong>. Isso a transforma em uma string irreversível.</li>
                            <li>O novo usuário é salvo no banco de dados com a senha já hasheada.</li>
                        </ul>
                        <div class="relative">
                            <button onclick="copyCode('signup-code', this)" class="absolute top-2 right-2 bg-slate-200 text-slate-700 px-2 py-1 rounded text-xs hover:bg-slate-300">Copiar</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-md text-sm overflow-x-auto"><code id="signup-code">// Exemplo conceitual em um auth.service.ts (NestJS)
import * as bcrypt from 'bcrypt';

async create(createUserDto: CreateUserDto) {
  const salt = await bcrypt.genSalt();
  const hashedPassword = await bcrypt.hash(createUserDto.password, salt);
  
  return this.prisma.user.create({
    data: {
      ...createUserDto,
      password: hashedPassword,
    },
  });
}</code></pre>
                        </div>
                    </div>

                    <!-- Passo 2: Login -->
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-2xl font-semibold mb-3 text-slate-800">2. Login e Geração de Tokens (Sign-In)</h3>
                        <p class="mb-4 text-slate-600">Após o login bem-sucedido, o backend gera dois tokens para o cliente.</p>
                        <ul class="list-disc list-inside space-y-2 mb-4 text-slate-600">
                            <li>O frontend envia `email` e `password`.</li>
                            <li>O backend busca o usuário pelo email. Se não encontrar, retorna erro.</li>
                            <li>Compara a senha enviada com a senha hasheada no banco usando <strong>bcrypt.compare()</strong>.</li>
                            <li>Se a senha for válida, gera dois tokens JWT:
                                <ul class="list-['-_'] list-inside ml-4 mt-1">
                                    <li><strong>Access Token:</strong> Vida curta (ex: 15 minutos). Usado para acessar recursos protegidos.</li>
                                    <li><strong>Refresh Token:</strong> Vida longa (ex: 7 dias). Usado apenas para obter um novo Access Token.</li>
                                </ul>
                            </li>
                            <li>O backend retorna os dois tokens para o frontend.</li>
                        </ul>
                        <div class="relative">
                            <button onclick="copyCode('signin-code', this)" class="absolute top-2 right-2 bg-slate-200 text-slate-700 px-2 py-1 rounded text-xs hover:bg-slate-300">Copiar</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-md text-sm overflow-x-auto"><code id="signin-code">// Exemplo da resposta da API após login
{
  "accessToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "refreshToken": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}</code></pre>
                        </div>
                    </div>

                    <!-- Passo 3: Armazenamento -->
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-2xl font-semibold mb-3 text-slate-800">3. Armazenamento Seguro dos Tokens</h3>
                        <p class="mb-4 text-slate-600">A forma como os tokens são armazenados no frontend é crucial para a segurança.</p>
                        <ul class="list-disc list-inside space-y-2 text-slate-600">
                            <li><strong>Access Token:</strong> É seguro armazená-lo na memória da aplicação (ex: em um store do Pinia). Ele é enviado em cada requisição para a API no header `Authorization: Bearer <token>`.</li>
                            <li><strong>Refresh Token:</strong> <strong>NÃO</strong> deve ser armazenado no `localStorage`. A melhor prática é armazená-lo em um <strong>cookie `HttpOnly`</strong>. Isso impede que scripts maliciosos (XSS) o acessem, pois ele só pode ser lido pelo servidor.</li>
                        </ul>
                    </div>

                    <!-- Passo 4: Protegendo Rotas -->
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-2xl font-semibold mb-3 text-slate-800">4. Acesso a Recursos Protegidos</h3>
                        <p class="mb-4 text-slate-600">O `accessToken` é a chave para acessar dados restritos.</p>
                        <ul class="list-disc list-inside space-y-2 mb-4 text-slate-600">
                            <li>O frontend (com Axios Interceptor) anexa o `accessToken` a cada requisição para rotas protegidas.</li>
                            <li>No backend (com um Guard do NestJS), a API verifica a validade e a expiração do token.</li>
                            <li>Se o token for válido, a requisição prossegue. Caso contrário, a API retorna um erro `401 Unauthorized`.</li>
                        </ul>
                        <div class="relative">
                            <button onclick="copyCode('guard-code', this)" class="absolute top-2 right-2 bg-slate-200 text-slate-700 px-2 py-1 rounded text-xs hover:bg-slate-300">Copiar</button>
                            <pre class="bg-slate-800 text-white p-4 rounded-md text-sm overflow-x-auto"><code id="guard-code">// Exemplo de como proteger um endpoint no NestJS
import { UseGuards } from '@nestjs/common';
import { JwtAuthGuard } from './jwt-auth.guard';

@Controller('profile')
export class ProfileController {
  @UseGuards(JwtAuthGuard)
  @Get()
  getProfile() {
    // Este código só executa se o accessToken for válido
    return { user: 'profile data' };
  }
}</code></pre>
                        </div>
                    </div>

                    <!-- Passo 5: Renovação de Token -->
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-2xl font-semibold mb-3 text-slate-800">5. Renovação do Access Token</h3>
                        <p class="mb-4 text-slate-600">Quando o `accessToken` expira (após 15 min, por exemplo), o sistema precisa obter um novo sem forçar o usuário a fazer login novamente.</p>
                        <ul class="list-disc list-inside space-y-2 text-slate-600">
                            <li>O frontend recebe o erro `401` da API.</li>
                            <li>Ele então faz uma chamada para um endpoint específico, como `/auth/refresh`.</li>
                            <li>Essa requisição envia o `refreshToken` (que estava no cookie `HttpOnly`) para o backend.</li>
                            <li>O backend valida o `refreshToken`. Se for válido, gera e retorna um <strong>novo `accessToken`</strong>.</li>
                            <li>O frontend substitui o `accessToken` antigo pelo novo e refaz a chamada original que falhou.</li>
                        </ul>
                    </div>
                </div>

                <div class="mt-10 bg-cyan-100 border-l-4 border-cyan-500 text-cyan-800 p-6 rounded-r-lg shadow">
                    <h3 class="text-2xl font-bold mb-2">⭐ Boas Práticas de Segurança</h3>
                    <ul class="list-disc list-inside space-y-1">
                        <li><strong>Sempre hasheie senhas:</strong> Nunca armazene senhas como texto simples. Use `bcrypt`.</li>
                        <li><strong>Use `HttpOnly` cookies para Refresh Tokens:</strong> Mitiga o risco de ataques XSS.</li>
                        <li><strong>Mantenha Access Tokens com vida curta:</strong> Reduz a janela de oportunidade caso um token seja vazado.</li>
                        <li><strong>Invalide Refresh Tokens no logout:</strong> Implemente uma lógica de logout no backend para invalidar o token de atualização (ex: adicionando a uma denylist).</li>
                        <li><strong>Valide todos os inputs:</strong> Use bibliotecas como Zod ou `class-validator` no NestJS para garantir que os dados recebidos pela API estão corretos.</li>
                    </ul>
                </div>
            </section>

            <section id="devops" class="tab-content fade-in">
                <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Docker</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-sky-600 bg-sky-200 mb-3">
                            Containerização
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Uma plataforma para desenvolver, enviar e executar aplicações em contêineres.
                            <br><strong>Como funciona:</strong> Empacota a aplicação e todas as suas dependências em uma "imagem" que pode ser executada de forma consistente em qualquer ambiente.
                            <br><strong>Vantagens:</strong> Elimina o "na minha máquina funciona", simplifica o deploy e garante a paridade entre ambientes.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">Vitest</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-lime-600 bg-lime-200 mb-3">
                            Framework de Testes Unificado
                        </span>
                        <p class="text-slate-600">
                            <strong>O que é:</strong> Um framework de testes unitários moderno e extremamente rápido, ideal para todo o ecossistema Vite.
                            <br><strong>Como funciona:</strong> Permite criar e executar testes para o frontend (Quasar) e backend (NestJS) com uma única ferramenta, garantindo consistência.
                            <br><strong>Vantagens:</strong> Unifica o processo de testes, simplifica o workflow da equipe e oferece performance superior, acelerando o ciclo de desenvolvimento.
                        </p>
                    </div>
                    <div class="bg-white p-6 rounded-lg shadow-sm border border-slate-200">
                        <h3 class="text-xl font-bold mb-2 text-slate-900">ESLint + Prettier</h3>
                        <span class="text-xs font-semibold inline-block py-1 px-2 uppercase rounded-full text-fuchsia-600 bg-fuchsia-200 mb-3">
                            Linting e Formatação
                        </span>
                        <p class="text-slate-600">
                            <strong>O que são:</strong> Ferramentas para manter a qualidade e a consistência do código.
                            <br><strong>Como funcionam:</strong> ESLint analisa o código em busca de erros. Prettier formata o código automaticamente seguindo um padrão definido.
                            <br><strong>Vantagens:</strong> Padronizam o estilo de código, evitam erros comuns e melhoram a legibilidade.
                        </p>
                    </div>
                </div>
            </section>
        </main>
    </div>

    <script>
        const tabs = document.querySelectorAll('.tab-btn');
        const contents = document.querySelectorAll('.tab-content');

        function showTab(tabId) {
            tabs.forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.tab === tabId) {
                    tab.classList.add('active');
                }
            });

            contents.forEach(content => {
                content.classList.remove('active');
                if (content.id === tabId) {
                    content.classList.add('active');
                }
            });
        }

        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                showTab(tab.dataset.tab);
            });
        });

        // Show the first tab by default
        document.addEventListener('DOMContentLoaded', () => {
            showTab('arquitetura');
        });

        // Copy to clipboard function
        function copyCode(elementId, buttonElement) {
            const codeEl = document.getElementById(elementId);
            const text = codeEl.innerText;

            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = text;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);

            // Show a temporary message
            buttonElement.innerText = 'Copiado!';
            setTimeout(() => {
                buttonElement.innerText = 'Copiar';
            }, 1500);
        }
    </script>
</body>

</html>